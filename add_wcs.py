#!/usr/bin/env python

# SPDX-License-Identifier: GPL-3.0-or-later
"""Add metadata and WCS to FF files generated by RMS"""

from glob import glob
import numpy as np
from RMS.Formats.Platepar import Platepar
from RMS.Astrometry.Conversions import jd2Date
from RMS.Formats.FFfile import getMiddleTimeFF, filenameToDatetime
from RMS.Astrometry.ApplyAstrometry import xyToRaDecPP

from astropy import wcs
from astropy.io import fits
from astropy.io.fits.header import Header
from astropy.time import Time

import logging

import json

import argparse
import RMS.ConfigReader

logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)


def solve_linear_equation(a, b):
    q, r = np.linalg.qr(a)
    y = np.dot(q.T, b)
    x = np.linalg.solve(r, y)
    return x


def fit_wcs(x, y, ra, dec, x0, y0, ra0, dec0, order):
    """
    Fit an astropy WCS object to given coordinates

    This function was made by Cees Bassa.

    Args:
      x (array[float]): Pixel x coordinates
      y (array[float]): Pixel y coordinates
      ra (array[float]: RA coordinates in degrees
      dec (array[float]: Dec coordinates in degrees
      x0 (float): center pixel x
      y0 (float): center pixel y
      ra0 (float): center pixel RA in degrees
      dec0 (float) center pixel DEC in degrees
      order: order of imaging polynomials

    Returns:
      WCS instance
    """
    dx, dy = x - x0, y - y0
    ixs, iys = np.meshgrid(np.arange(order + 1), np.arange(order + 1))
    c = ixs + iys <= order
    ix, iy = ixs[c], iys[c]
    a = np.array([dx**ix[i] * dy**iy[i] for i in range(len(iy))]).T

    for k in range(5):
        w = wcs.WCS(naxis=2)
        w.wcs.ctype = ["RA---ZEA", "DEC--ZEA"]
        w.wcs.cd = [[1.0, 0.0], [0.0, 1.0]]
        w.wcs.crval = [ra0, dec0]
        w.wcs.crpix = [0.0, 0.0]
        rx, ry = w.wcs_world2pix(np.stack((ra, dec), axis=-1), 1).T
        ax = solve_linear_equation(a, rx)
        ay = solve_linear_equation(a, ry)
        ra0, dec0 = w.wcs_pix2world(([[ax[0], ay[0]]]), 1)[0]
    cd = np.array([[ax[1], ax[order + 1]], [ay[1], ay[order + 1]]])
    cdinv = np.linalg.inv(cd)
    axm = np.zeros_like(ixs).astype("float32")
    aym = np.zeros_like(ixs).astype("float32")
    for i in range(len(ix)):
        if ix[i] + iy[i] >= 2:
            p = np.matmul(cdinv, np.array([ax[i], ay[i]]))
            axm[iy[i], ix[i]] = p[0]
            aym[iy[i], ix[i]] = p[1]
    w = wcs.WCS(naxis=2)
    w.wcs.ctype = ["RA---ZEA-SIP", "DEC--ZEA-SIP"]
    w.wcs.cd = cd
    w.wcs.crval = [ra0, dec0]
    w.wcs.crpix = [x0, y0]
    w.sip = wcs.Sip(axm.T, aym.T, None, None, w.wcs.crpix)

    return w


with open("platepars_all_recalibrated.json", "r") as f:
    platepars_recalibrated = json.load(f)


def add_wcs(ff_filename, star_list_xy, config):
    platepar_recalibrated = Platepar()
    try:
        platepar_data = platepars_recalibrated[ff_filename]
        with open("platepar_tmp.cal", "w") as f:
            json.dump(platepar_data, f)
        platepar_recalibrated.read("platepar_tmp.cal")
    except (FileNotFoundError, KeyError):
        platepar_recalibrated.read("platepar_cmn2010.cal")
        logger.warning("Using non-recalibrated platepar")

    fftime = getMiddleTimeFF(ff_filename, config.fps)

    _, fit_ra, fit_dec, _ = xyToRaDecPP([fftime] * len(fit_xy),
                                        fit_xy[:, 0],
                                        fit_xy[:, 1], [1] * len(fit_xy),
                                        platepar_recalibrated,
                                        extinction_correction=False)

    x0 = platepar_recalibrated.X_res / 2
    y0 = platepar_recalibrated.Y_res / 2
    _, ra0, dec0, _ = xyToRaDecPP([fftime], [x0], [y0], [1],
                                  platepar_recalibrated,
                                  extinction_correction=False)
    w = fit_wcs(fit_xy[:, 0], fit_xy[:, 1], fit_ra, fit_dec, x0, y0, ra0[0],
                dec0[0], 5)

    hdu_list = fits.open(ff_filename)
    obstime = Time(filenameToDatetime(ff_filename))

    header_meta = {}
    header_meta["OBSERVER"] = config.stationID.strip()
    header_meta["INSTRUME"] = "Global Meteor Network"
    header_meta["MJD-OBS"] = obstime.mjd
    header_meta["DATE-OBS"] = obstime.fits
    header_meta["NFRAMES"] = 256
    header_meta["EXPTIME"] = 256 / config.fps
    header_meta["SITELONG"] = round(config.longitude, 2)
    header_meta["SITELAT"] = round(config.latitude, 2)

    for hdu in hdu_list:
        if hdu.header["NAXIS"] == 0:  # First header is not an image so should not get WCS
            new_header = Header()
        else:
            new_header = w.to_fits(relax=True)[0].header

        for key, value in header_meta.items():
            new_header.append((key, value))

        for key, value in new_header.items():
            if key in hdu.header:
                continue
            hdu.header[key] = value

    hdu_list.writeto(ff_filename, overwrite=True)


if __name__ == "__main__":
    config = RMS.ConfigReader.parse(".config")

    global_platepar = Platepar()
    global_platepar.read("platepar_cmn2010.cal")

    fit_xy = np.array(global_platepar.star_list)[:, 1:3]

    for ff_filename in glob("FF*fits"):
        logger.info(f"Updating {ff_filename}")
        add_wcs(ff_filename, fit_xy, config)
        break # TODO remove
